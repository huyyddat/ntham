<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gửi Cục Dàng</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=VT323&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body, html {
            width: 100%; height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'VT323', monospace;
        }
        canvas { display: block; }
        
        #portrait-warning {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            color: #ff6b81;
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        #portrait-warning h2 {
            font-family: 'Dancing Script', cursive;
            font-size: 2.5rem; margin-bottom: 15px;
        }
        #portrait-warning p {
            font-family: 'VT323', monospace;
            font-size: 1.5rem; letter-spacing: 1px;
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 20px;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        @media screen and (orientation: portrait) {
            #portrait-warning { display: flex; }
            canvas { display: none; }
            #loading { display: none; }
        }
    </style>
</head>
<body>
    <div id="loading">Đang chuẩn bị quà...</div>
    
    <div id="portrait-warning">
        <h2>Heluuuu!</h2>
        <p>XOAY NGANG ĐIỆN THOẠI ĐỂ XEM NHÉ ❤️</p>
    </div>

    <canvas id="myCanvas"></canvas>

    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');

        let width = 0, height = 0;
        let particles = [];
        let hearts = [];
        let currentPhrase = 0;
        let animationId;
        let intervalId;
        
        const phrases = [
            "Heluuuuuu cục dàng yêu của tui",
            "Biết là có vài món quà",
            "gửi tới tay cục dàng rùi",
            "Nhưng mà dù gì hôm nay",
            "Cũng là valentine mà",
            "Tặng cục dàng yêu",
            "Thêm tí màu mè này",
            "Rằng là:",
            "Chúc cục dàng, em bé,\nvợ của tui ngày nàoooo\ncũng cười tươi",
            "hạnh phúc quài quài\nmãi mãi lun",
            "Yêu em ❤️"
        ];

        // CẤU HÌNH TINH CHỈNH
        const CONFIG = {
            step: 3,         
            baseSize: 2,     
            speed: 0.09,     // Giảm tốc độ xuống còn 60% so với cũ (0.15 -> 0.09)
            snapDistance: 1  
        };

        function resize() {
            width = canvas.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            height = canvas.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- TRÁI TIM NỀN ---
        class Heart {
            constructor() { this.reset(true); }
            reset(randomY = false) {
                const w = width || window.innerWidth;
                const h = height || window.innerHeight;
                
                this.x = Math.random() * w;
                this.y = randomY ? Math.random() * h : -50;
                // Giảm kích thước trái tim (từ 1-3 xuống còn 0.5-2)
                this.size = Math.random() * 1.5 + 0.5; 
                this.speed = Math.random() * 1.5 + 0.5;
                this.color = `hsl(${Math.random() * 40 + 320}, 100%, 60%)`;
                this.opacity = Math.random() * 0.5 + 0.3;
            }
            update() {
                const h = height || window.innerHeight;
                this.y += this.speed;
                if (this.y > h + 50) this.reset();
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x, this.y);
                ctx.scale(this.size, this.size);
                
                // Thêm hiệu ứng phát sáng (Glow)
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(-5, -5, -10, 5, 0, 15);
                ctx.bezierCurveTo(10, 5, 5, -5, 0, 0);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Reset shadow để không ảnh hưởng các object khác nếu không muốn
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        // --- HẠT CHỮ (PIXEL) ---
        class Particle {
            constructor(x, y) {
                const w = width || window.innerWidth;
                const h = height || window.innerHeight;
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.tx = x; 
                this.ty = y; 
                this.vx = 0;
                this.vy = 0;
                this.color = `hsl(${Math.random() * 60 + 330}, 100%, 85%)`;
                this.docked = false; 
            }
            update() {
                if (this.docked) return;

                let dx = this.tx - this.x;
                let dy = this.ty - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < CONFIG.snapDistance) {
                    this.x = this.tx;
                    this.y = this.ty;
                    this.docked = true;
                } else {
                    this.vx = dx * CONFIG.speed;
                    this.vy = dy * CONFIG.speed;
                    this.x += this.vx;
                    this.y += this.vy;
                }
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(Math.floor(this.x), Math.floor(this.y), CONFIG.baseSize, CONFIG.baseSize);
            }
        }

        function createTextParticles(text) {
            if (!width || !height) {
                resize();
                if (!width || !height) return;
            }

            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');
            offCanvas.width = width;
            offCanvas.height = height;

            let fontSize = Math.min(width * 0.15, 90); 
            if (currentPhrase === phrases.length - 1) fontSize = Math.min(width * 0.18, 130);

            offCtx.fillStyle = '#fff';
            offCtx.font = `${fontSize}px 'VT323', 'Courier New', monospace`;
            offCtx.textAlign = 'center';
            offCtx.textBaseline = 'middle';

            const lines = text.split('\n');
            const lineHeight = fontSize * 1.1;
            const startY = (height - (lines.length - 1) * lineHeight) / 2;

            lines.forEach((line, index) => {
                offCtx.fillText(line, width / 2, startY + index * lineHeight);
            });

            try {
                const imageData = offCtx.getImageData(0, 0, width, height);
                const data = imageData.data;
                let newTargets = [];
                
                for (let y = 0; y < height; y += CONFIG.step) {
                    for (let x = 0; x < width; x += CONFIG.step) {
                        const alpha = data[(y * width + x) * 4 + 3];
                        if (alpha > 128) {
                            newTargets.push({ x, y });
                        }
                    }
                }

                newTargets.sort(() => Math.random() - 0.5);

                if (particles.length < newTargets.length) {
                    const toAdd = newTargets.length - particles.length;
                    for(let i = 0; i < toAdd; i++) {
                        particles.push(new Particle(width/2, height/2));
                    }
                } else if (particles.length > newTargets.length) {
                    particles.splice(newTargets.length);
                }

                for(let i = 0; i < particles.length; i++) {
                    particles[i].tx = newTargets[i].x;
                    particles[i].ty = newTargets[i].y;
                    particles[i].docked = false;
                    particles[i].color = `hsl(${Math.random() * 40 + 330}, 100%, 85%)`; 
                }
            } catch (e) {
                console.error("Lỗi khi lấy dữ liệu ảnh:", e);
            }
        }

        function animate() {
            if (!width || !height) return;

            // Giảm độ trong suốt của lớp phủ màu đen (từ 0.25 xuống 0.1)
            // Điều này làm cho hình ảnh cũ mờ đi chậm hơn -> tạo hiệu ứng dư ảnh (trails) dài hơn
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);

            hearts.forEach(heart => {
                heart.update();
                heart.draw();
            });

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            animationId = requestAnimationFrame(animate);
        }

        function init() {
            resize();
            if (width <= 0 || height <= 0) {
                setTimeout(init, 200);
                return;
            }

            if (hearts.length === 0) {
                for (let i = 0; i < 50; i++) hearts.push(new Heart()); // Tăng số lượng tim lên một chút vì tim nhỏ hơn
            }

            loading.style.opacity = 0;
            
            createTextParticles(phrases[currentPhrase]);
            animate();

            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => {
                currentPhrase++;
                if (currentPhrase < phrases.length) {
                    createTextParticles(phrases[currentPhrase]);
                } else {
                    clearInterval(intervalId); 
                }
            }, 5000);
        }

        const fontLoadPromise = document.fonts.ready;
        const timeoutPromise = new Promise(resolve => setTimeout(resolve, 1000));

        Promise.race([fontLoadPromise, timeoutPromise]).then(() => {
            setTimeout(init, 200); 
        });

    </script>
</body>
</html>
